<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sphere in a homogenous field · LaplaceBIE.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LaplaceBIE.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">LaplaceBIE.jl theory (Magnetic or electric force for a smooth bodies)</a></li><li class="current"><a class="toctext" href>Sphere in a homogenous field</a><ul class="internal"><li><a class="toctext" href="#Analytics-1">Analytics</a></li><li><a class="toctext" href="#Numerics-1">Numerics</a></li><li><a class="toctext" href="#Comparission-1">Comparission</a></li></ul></li><li><a class="toctext" href="../pointlike/">Sphere in a point charge field.</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Sphere in a homogenous field</a></li></ul><a class="edit-page" href="https://github.com/akels/LaplaceBIE.jl/blob/master/examples/homogenous.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Sphere in a homogenous field</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Sphere-in-a-homogenous-field-1" href="#Sphere-in-a-homogenous-field-1">Sphere in a homogenous field</a></h1><h2><a class="nav-anchor" id="Analytics-1" href="#Analytics-1">Analytics</a></h2><p>To test numerics we can use analytical solution for ellipsoid in a homogenous field. In such case the internal field is given through demagnetization coefficients:</p><div>\[H_i = \frac{H_{0i}}{(1 + (\mu-1)n_i)}\]</div><pre><code class="language-julia">using QuadGK

function ellipsoid_demagnetization_coefficients(a,b,c)

    UP_BOUND = 1000

    Ru2(u) = (u+a^2)*(u+b^2)*(u+c^2)

    nx = 1/2 * a*b*c * quadgk(s -&gt; 1/(s+a^2)/sqrt(Ru2(s)), 0, UP_BOUND)[1]
    ny = 1/2 * a*b*c * quadgk(s -&gt; 1/(s+b^2)/sqrt(Ru2(s)), 0, UP_BOUND)[1]
    nz = 1/2 * a*b*c * quadgk(s -&gt; 1/(s+c^2)/sqrt(Ru2(s)), 0, UP_BOUND)[1]

    return [nx, ny, nz]
end

function EllipsoidField(a,b,c,mu,H0)

    H0x, H0y, H0z = H0
    nx, ny, nz = ellipsoid_demagnetization_coefficients(a,b,c)

    Hix = H0x/(1 + (mu-1)*nx)
    Hiy = H0y/(1 + (mu-1)*ny)
    Hiz = H0z/(1 + (mu-1)*nz)

    return [Hix,Hiy,Hiz]
end</code></pre><pre><code class="language-none">EllipsoidField (generic function with 1 method)</code></pre><h2><a class="nav-anchor" id="Numerics-1" href="#Numerics-1">Numerics</a></h2><p>First a spherical mesh is loaded from <code>SoftSurfaceDynamics.jl</code> package. We also need normals for the mesh for boundary integral equations which crudelly can also be calculated with <code>SoftSurfaceDynamics.normals</code> method. However here more sensible approach is to take normal vectors the vertices themselves.</p><p>A method for generating sphere mesh from subdivissions of icosahedron</p><pre><code class="language-">using GeometryTypes
using LinearAlgebra

&quot;&quot;&quot;
    subdivide(msh::HomogenousMesh,f::Function)

Returns a subdived triangular mesh from passed mesh `msh` and interpolator function `f`. The interpolator `f` is expected to accept two vertex indicies of the edge and to return a tuple of coordinates of the middle point (as one wishes to define it).
&quot;&quot;&quot;
function subdivide(msh::HomogenousMesh,f::Function)
    edges = filter(x-&gt;x[1]&lt;x[2],decompose(Face{2,Int},msh))
    epoint(v1,v2) = findfirst(x-&gt;x==(v2&gt;v1 ? Face(v1,v2) : Face(v2,v1)), edges) + length(msh.vertices)

    newfaces = Face{3,Int}[]

    newvertices = copy(msh.vertices)
    resize!(newvertices,length(msh.vertices) + length(edges))

    for (v1,v2,v3) in msh.faces

        ev3 = epoint(v1,v2)
        ev1 = epoint(v2,v3)
        ev2 = epoint(v3,v1)

        ### Usually, does assignment twice but is important if the surface is not tightly connected
        newvertices[ev3] = Point(f(v1,v2)...)
        newvertices[ev1] = Point(f(v2,v3)...)
        newvertices[ev2] = Point(f(v3,v1)...)

        push!(newfaces,Face(v1,ev3,ev2))
        push!(newfaces,Face(v2,ev1,ev3))
        push!(newfaces,Face(v3,ev2,ev1))
        push!(newfaces,Face(ev1,ev2,ev3))
    end

    return HomogenousMesh(newvertices,newfaces)
end

&quot;&quot;&quot;
    unitsphere(n)

Returns a sphere mesh made out of icosahedron subdivided `n` times.
&quot;&quot;&quot;
function unitsphere(subdivissions::Int64)
    t = ( 1 + sqrt( 5 ) ) / 2;

    vertices = Point{3,Float64}[
        [ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],
        [  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],
        [  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]
    ]

    faces = Face{3,Int64}[
        [1, 12, 6], [1, 6, 2], [1, 2, 8], [1, 8, 11], [1, 11, 12], [2, 6, 10], [6, 12, 5],
        [12, 11, 3], [11, 8, 7], [8, 2, 9], [4, 10, 5], [4, 5, 3], [4, 3, 7], [4, 7, 9],
        [4, 9, 10], [5, 10, 6], [3, 5, 12], [7, 3, 11], [9, 7, 8], [10, 9, 2]
    ]

    msh = HomogenousMesh(vertices ./ sqrt(1+t^2),faces)

    function sf(msh,v1,v2)
        p1 = msh.vertices[v1]
        p2 = msh.vertices[v2]
        return (p1 + p2)/norm(p1+p2)
    end


    for i in 1:subdivissions
        msh = subdivide(msh,(v1,v2)-&gt;sf(msh,v1,v2))
    end

    return msh
end

msh = unitsphere(3)
vertices, faces = msh.vertices, msh.faces
n = vertices
# The question is whether that is because of normal calculation method fault or due to sphere being incorrectly orriented.</code></pre><p>Now we can define our problem with a field <span>$H_0 = e_z$</span> and <span>$\epsilon=15$</span>. A corresponding potential for that is <span>$\psi = z$</span> which we need to pass to the solver.</p><pre><code class="language-">using LaplaceBIE
using LinearAlgebra
using GeometryTypes
using SurfaceTopology

ϵ = 15
H0 = [0,0,1]

freepotential(x) = dot(x,H0)
freefield(x) = H0</code></pre><p>For finding solution of the problem we execute a line:</p><pre><code class="language-">ψ = surfacepotential(vertices,n,faces,ϵ,freepotential)</code></pre><p>which solves a regularized boundary integral equation. And gives the potential on the surface. That then allows to obtain solution everywhere on the space very easally except near the boundary.</p><p>The library offers also to recalculate the pontential gradient on the surface which is needed for example to calculate the surface force due to <span>$(M \cdot \nabla)H$</span>.</p><p>The tnagential derivatives can be easally claculated from the potential by a finite differences which can be executed.</p><pre><code class="language-">P∇ψ = tangentderivatives(vertices,n,faces,ψ)</code></pre><p>The normal derivatives are calculated from Biot-Savarat law treating tangential field as raising from a surface current.</p><pre><code class="language-">n∇ψ = normalderivatives(vertices,n,faces,P∇ψ,ϵ,freefield)</code></pre><h2><a class="nav-anchor" id="Comparission-1" href="#Comparission-1">Comparission</a></h2><p>Since normals are the same as vertices for the nit spehre we expect normal field and potential to be the same. As can be seen from the results they indeed are:</p><pre><code class="language-">Hin = EllipsoidField(1,1,1,ϵ,H0)

x = [v[3] for v in vertices]
sp = sortperm(x)

for xkey in sp[1:20:end]
    psit = dot(Hin,vertices[xkey])
    println(&quot;$(vertices[xkey][3]) \t $psit \t $(ψ[xkey]) \t $(n∇ψ[xkey])&quot;)
end</code></pre><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">LaplaceBIE.jl theory (Magnetic or electric force for a smooth bodies)</span></a><a class="next" href="../pointlike/"><span class="direction">Next</span><span class="title">Sphere in a point charge field.</span></a></footer></article></body></html>
