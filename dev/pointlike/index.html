<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sphere in a point charge field. · LaplaceBIE.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LaplaceBIE.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">LaplaceBIE.jl theory (Magnetic or electric force for a smooth bodies)</a></li><li><a class="toctext" href="../homogenous/">Sphere in a homogenous field</a></li><li class="current"><a class="toctext" href>Sphere in a point charge field.</a><ul class="internal"><li><a class="toctext" href="#Analytics-and-the-problem-1">Analytics and the problem</a></li><li><a class="toctext" href="#Numerics-1">Numerics</a></li><li><a class="toctext" href="#Comparision-1">Comparision</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Sphere in a point charge field.</a></li></ul><a class="edit-page" href="https://github.com/akels/LaplaceBIE.jl/blob/master/examples/pointlike.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Sphere in a point charge field.</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Sphere-in-a-point-charge-field.-1" href="#Sphere-in-a-point-charge-field.-1">Sphere in a point charge field.</a></h1><h2><a class="nav-anchor" id="Analytics-and-the-problem-1" href="#Analytics-and-the-problem-1">Analytics and the problem</a></h2><p>In general the LaplaceBIE allows to find field on the object if the potential in absence of objects is known. To demonstrate that let&#39;s consider a field on the dielectric sphere (radius <span>$r_1$</span>) due to a point charge at distance <span>$\zeta$</span> away. The solution inside the sphere is given as series [Straton page 221]:</p><div>\[\psi = \sum_{n=0}^{\infty} \frac{2n + 1}{\epsilon n + n + 1} \frac{r_1^n}{\zeta^{n+1}} L_n(\cos \theta)\]</div><p>where <span>$L_n$</span> is Legendre polynomial and <span>$\theta$</span> angle from line connecting point charge and spehre.</p><p>The normal derivative can also be given for the sphere which coincides with derivative in the radial direction</p><div>\[\frac{\partial \psi}{\partial n} = \sum_{n=0}^{\infty} \frac{n(2n + 1)}{\epsilon n + n + 1} \frac{r_1^{n-1}}{\zeta^{n+1}} L_n(\cos \theta)\]</div><pre><code class="language-julia">using Jacobi

function ψt(cosθ,ϵ,ζ,r1)
    s = 0
    for n in 0:25
        s += (2*n + 1)/(n*ϵ + n + 1)*r1^n/ζ^(n+1)*legendre(cosθ,n)
    end
    return s
end

function ∇ψn(cosθ,ϵ,ζ,r1)
    s = 0
    for n in 1:25
        s += n*(2*n + 1)/(n*ϵ + n + 1)*r1^(n-1)/ζ^(n+1) * legendre(cosθ,n)
    end
    return s
end</code></pre><pre><code class="language-none">∇ψn (generic function with 1 method)</code></pre><h2><a class="nav-anchor" id="Numerics-1" href="#Numerics-1">Numerics</a></h2><p>First we need to load a sphere mesh.</p><pre><code class="language-">using LinearAlgebra
using GeometryTypes
using SurfaceTopology
using LaplaceBIE</code></pre><p>A method for generating sphere mesh from subdivissions of icosahedron</p><pre><code class="language-">using GeometryTypes
using LinearAlgebra

&quot;&quot;&quot;
    subdivide(msh::HomogenousMesh,f::Function)

Returns a subdived triangular mesh from passed mesh `msh` and interpolator function `f`. The interpolator `f` is expected to accept two vertex indicies of the edge and to return a tuple of coordinates of the middle point (as one wishes to define it).
&quot;&quot;&quot;
function subdivide(msh::HomogenousMesh,f::Function)
    edges = filter(x-&gt;x[1]&lt;x[2],decompose(Face{2,Int},msh))
    epoint(v1,v2) = findfirst(x-&gt;x==(v2&gt;v1 ? Face(v1,v2) : Face(v2,v1)), edges) + length(msh.vertices)

    newfaces = Face{3,Int}[]

    newvertices = copy(msh.vertices)
    resize!(newvertices,length(msh.vertices) + length(edges))

    for (v1,v2,v3) in msh.faces

        ev3 = epoint(v1,v2)
        ev1 = epoint(v2,v3)
        ev2 = epoint(v3,v1)

        ### Usually, does assignment twice but is important if the surface is not tightly connected
        newvertices[ev3] = Point(f(v1,v2)...)
        newvertices[ev1] = Point(f(v2,v3)...)
        newvertices[ev2] = Point(f(v3,v1)...)

        push!(newfaces,Face(v1,ev3,ev2))
        push!(newfaces,Face(v2,ev1,ev3))
        push!(newfaces,Face(v3,ev2,ev1))
        push!(newfaces,Face(ev1,ev2,ev3))
    end

    return HomogenousMesh(newvertices,newfaces)
end

&quot;&quot;&quot;
    unitsphere(n)

Returns a sphere mesh made out of icosahedron subdivided `n` times.
&quot;&quot;&quot;
function unitsphere(subdivissions::Int64)
    t = ( 1 + sqrt( 5 ) ) / 2;

    vertices = Point{3,Float64}[
        [ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],
        [  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],
        [  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]
    ]

    faces = Face{3,Int64}[
        [1, 12, 6], [1, 6, 2], [1, 2, 8], [1, 8, 11], [1, 11, 12], [2, 6, 10], [6, 12, 5],
        [12, 11, 3], [11, 8, 7], [8, 2, 9], [4, 10, 5], [4, 5, 3], [4, 3, 7], [4, 7, 9],
        [4, 9, 10], [5, 10, 6], [3, 5, 12], [7, 3, 11], [9, 7, 8], [10, 9, 2]
    ]

    msh = HomogenousMesh(vertices ./ sqrt(1+t^2),faces)

    function sf(msh,v1,v2)
        p1 = msh.vertices[v1]
        p2 = msh.vertices[v2]
        return (p1 + p2)/norm(p1+p2)
    end


    for i in 1:subdivissions
        msh = subdivide(msh,(v1,v2)-&gt;sf(msh,v1,v2))
    end

    return msh
end

msh = unitsphere(2)
vertices, faces = msh.vertices, msh.faces
n = vertices</code></pre><p>The next step is to set up the free field solution which we do as follows</p><pre><code class="language-julia">ζ = 1.2
r1 = 1
y = [0,0,ζ]

freepotential(x) = 1/norm(x.-y)
freefield(x) = -(x.-y)/norm(x.-y)^3</code></pre><pre><code class="language-none">freefield (generic function with 1 method)</code></pre><p>Then in a presence of a sphere with <span>$\epsilon=10$</span> we have a solution:</p><pre><code class="language-">ϵ = 10
ψ = surfacepotential(vertices,n,faces,ϵ,freepotential)
P∇ψ = tangentderivatives(vertices,n,faces,ψ)
n∇ψ = normalderivatives(vertices,n,faces,P∇ψ,ϵ,freefield)</code></pre><h2><a class="nav-anchor" id="Comparision-1" href="#Comparision-1">Comparision</a></h2><pre><code class="language-">using Winston

cosθ = range(-1,1,length=100)
cosθs = [x[3]/1 for x in vertices]</code></pre><p>Potential test</p><pre><code class="language-">scatter(cosθs,ψ)
oplot(cosθ,ψt.(cosθ,ϵ,ζ,r1) )</code></pre><p>Test of normal derivatives derivatives</p><pre><code class="language-">scatter(cosθs,n∇ψ)
oplot(cosθ,∇ψn.(cosθ,ϵ,ζ,r1) )</code></pre><footer><hr/><a class="previous" href="../homogenous/"><span class="direction">Previous</span><span class="title">Sphere in a homogenous field</span></a></footer></article></body></html>
